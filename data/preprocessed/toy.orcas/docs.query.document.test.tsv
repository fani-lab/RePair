Navigational: https//support.google.com/accounts/answer/27441?hl=en create a google account create a google account you can sign up for a google account to use gmail  google+  you tube  and other google products. make a new account to set up a google account  go to the create your google account page. on any google sign-in page  you can also select more options create account. check if you already have a google account if youve signed in to any google product before (like gmail  maps  or you tube)  you already have a google account. you can use the same username and password you created for that product to sign in to any other google products. if you cant remember ever signing in and would like to check if you have an account  enter your email address. if theres no google account associated with your email address  youll get a message that says so. if you forgot your username or password  follow the steps to recover your account. check where email notifications are sent if you signed up for gmail with your google account  we'll send all account-related notification emails to your gmail address. to change where you get notifications  sign in to my account your personal info email. share this nick is an accounts expert and the author of this help page. leave him feedback below about how to improve it. was this article helpful? yes no https//myaccount.google.com/intro my account welcome control your google experience  all in one place my account gives you quick access to settings and tools for managing your google experience on products like search and maps. you can manage some privacy settings now  and access even more privacy and security controls if you sign in or create a google account. sign in or create your google account https//www.google.com/gmail/about/ the ease & simplicity of gmail  available across devices the ease & simplicity of gmail  available across devices create an accountmeet your new inbox new customizable tabs put you back in control so that you can see what's new at a glance and decide which emails you want to read and when. experience gmail on any device the ease & simplicity of gmail  wherever you are view attachments instantly view files without leaving gmail. you can even save attachments directly to your drive to organize and share them in a single  safe place. custom themes the number of themes has increased from 35 to...infinity. select your own image to use as a custom theme  or choose from a selection of photos. take action right from the inbox track packages  review products  rsvp for events  and more without opening any emails. a better compose compose new messages while keeping an eye on your inbox. gmail's compose is fast  easy to use  and packed with features. get custom email & more with gmail for work use the gmail you love - for business. get custom email @yourcompany.com including calendar  docs  video meetings  and more with access from your phone or tablet. learn moreget started https//myaccount.google.com/intro/security manage your account access and security settings manage your account access and security settings every google account comes with todays most advanced security features built in. sign in to see if your security settings are up to date. security checkup protect your account in just a few minutes by reviewing your security settings and activity get started find your phone whether you forgot where you left it or it was stolen  a few steps may help secure your phone or tablet get started signing in to google set your account sign-in and recovery options. you can sign in with a password (what most people choose)  or add 2-step verification  which sends a code to your phone as an extra security step. if you forget your password or something else goes wrong  you can use a recovery email or recovery phone number to get back into your account. sign in device activity & security events when you're signed in  you can review devices that have recently accessed your account. sign in apps with account access sign in to review the apps and sites you've approved to connect with your account  and keep track of your saved passwords. sign in check your privacy settings your security comes first in everything we do. learn more https//support.google.com/mail/answer/56256?hl=en create a gmail account create a gmail account to sign up for gmail  create a google account. you can use the username and password to sign in to gmail and other google products like you tube  google play  and google drive. go to the google account creation page. follow the steps on the screen to set up your account. use the account you created to sign in to gmail. create an account the username i want is taken you wont be able to get a certain gmail address if the username you requested is already being used very similar to an existing username (for example  if example@gmail.com already exists  you cant use examp1e@gmail.com)the same as a username that someone used in the past and then deleted reserved by google to prevent spam or abuse someone is impersonating me if you believe someone has created a gmail address to try to impersonate your identity  you can file a report with the internet crime complaint center contact your states office of consumer protection unfortunately  gmail is unable to participate in mediations involving third parties regarding impersonation. learn more in gmail terms of use. share this michelle is a gmail expert and the author of this help page. leave her feedback about this help page. was this article helpful? yes no	google account sign up
"Instrumental: https//www.gov.uk/register-to-vote register to vote home citizenship and living in the uk voting register to vote use this service to apply to register to vote. this service is also available in welsh (cymraeg). you only need to register once - you don't need to register separately for every election. you must register again if you've changed address  name or nationality. you can also use this service tochange the way you vote - for example in person  by post or by proxyget on or off the open register it usually takes about 5 minutes. you need to register by 17 april to vote in the local and mayoral elections in england on 3 may. you may need the following  if you have themyour national insurance numberyour passport if you're a british citizen living abroad you need to be on the electoral register to vote in elections and referendums. there's a different process to register anonymously  for example if you're concerned about your safety. start now before you start you can also register by post. you can't register to vote if you're in the uk illegally. public servants posted overseas there are separate registration services for public servants who are likely to be posted overseas crown servants (for example members of the diplomatic service or overseas civil service)british council employeesarmed forces you should also use these registration services if you're the spouse or civil partner of a public servant posted overseas. you can still register as a non-service voter if you're in the armed forces and have a permanent home address in the uk. northern ireland this service is for england  wales and scotland only. you'll need to register using a different form if you live in northern ireland. last updated 27 march 2018related content the electoral register and the open registerways of voting explore the topic voting is this page useful? yes no is there anything wrong with this page? https//www.gov.uk/electoral-register overview overview the electoral register (sometimes called the 'electoral roll') lists the names and addresses of everyone who's registered to vote. get on the electoral register (or update your details)use the register to vote service toget on the electoral registerupdate your details (for example change your name or address)contact your local electoral registration office if you're not sure whether you're already on the register. what happens if you don't register you must register to vote if you're asked to do so and you meet the conditions for registering  for example you're 16 or over and you're british or a national of an eu or commonwealth country. if you're asked to register and don't do so  your local electoral registration office could fine you £80. you won't be fined if you have a valid reason for not registering  for example a long stay in hospital  or you have severe learning difficulties. when you can register in more than one place it's sometimes possible to register at 2 addresses (though you can only vote once in any election). for example  if you're a student with different home and term-time addresses  you may be able to register at both. use the register to vote service to make 2 separate applications. your local electoral registration office will look at each application and tell you whether you're allowed to register. next view the electoral register print entire guide https//teamrv-mvp.sos.texas.gov/mvp/mvp.do . use the log in to check your voter registration status poll location early voting locations registration information key election dates not registered to vote? register login selection criteria submit clear note am i registered? provides a web-based search of data extracted from texas's statewide voter registration database. it is not the official record of your registration  which is retained by the voter registration office in the county of your residence. https//www.headcount.org/verify-voter-registration/ verify your registration status + find your polling place go to voter info hub verify your registration status + find your polling place select your state go state find your registration status or polling place online or by phone asking yourself ""am i registered to vote?"" or not sure where to vote? you can verify your voter registration status online or by phone in most states. you can also check your polling place. to check your status or find your polling place online  just select your state above and follow the directions. to check by phone  you will probably need to speak with your county or city election board. the number can most easily be found through a web search  by typing in the name of your county or city and ""election board "" or by calling the state election office number below and requesting the number of your local election board. for other questions  call 866-our-vote https//www.usa.gov/register-to-vote register to vote and confirm or change registration register to vote and confirm or change registration learn if youre eligible to vote  how to register  check  or update your information. whats on this page voting rules in the u. s. are different in every state register to vote voter registration deadlines who can and who can't vote check or update your voter registration how  when  why voting rules in the u. s. are different in every state federal and state elections in the united states are run by the states themselves  according to article i and article ii of the constitution. no two states run their elections exactly the same  so contacting your state or local election office is the best way to find out about your state's unique election rules. the basic steps to vote are the same in most states despite the differences in how states run elections  the basic steps to vote are the same almost everywhere. every state except north dakota requires you to register to vote. every state has absentee voting. most states assign you a specific polling place  or voting location. a few states have ballot drop sites instead. these voting guides explain the basics of voting  no matter where you live a voter's guide to federal elections ( pdf  download adobe reader)14 facts about voting in federal elections ( pdf  download adobe reader)back to top register to vote if you need to register to vote  visit vote.gov. depending on your state's voter registration rules  the site can help you register online. this is available for 37 states plus the district of columbia. download the national mail voter registration form. you can fill it out onscreen and print the completed form  or print the blank form and fill it out by hand. remember to sign the form before mailing it to the location listed for your state. find guidance for states and territories with different registration procedures. start your voter registration register to vote in person you can register in person with your state or local election office. if it's more convenient for you to register elsewhere  you can check with one of these nearby public facilities to see if you can register to vote there the department of motor vehicles armed services recruitment centers state and county public assistance offices ( snap/food stamps  wic  services for the disabled)  where you may fill out and submit a national mail voter registration form. overseas and military voters if you're a u. s. citizen living outside the u. s.  or if you're a service member  service member's spouse  or eligible family member  you can register to vote and request an absentee ballot through the federal voting assistance program. register to vote in other languages the national mail voter registration form  which you must print  complete  sign  and mail to the location listed for your state  is available in bengali  chinese  hindi  japanese  khmer  korean  spanish  tagalog  and vietnamese. voters guides  which include information on registering to vote  are available in cherokee  chinese  dakota  japanese  korean  navajo  spanish  tagalog  vietnamese  and yupik. learn about the voting process if you have questions about the steps involved in voting  these guides from the election assistance commission are a good place to start a voter's guide to federal elections ( pdf  download adobe reader)14 facts about voting in federal elections ( pdf  download adobe reader)back to top voter registration deadlines every state except north dakota requires citizens to register if they want to become voters. depending on your state  the registration deadline could be as much as a month before an election. check the u. s. vote foundation to find your states deadline for registering. you can also check your state or territorys election office for more details. back to top who can and who can't vote who can vote? check with your state or local election office for any questions about who can and cannot vote. use this interactive map to earn more about what type of id if any is required to vote in your state. you can vote in u. s. elections if you are a u. s. citizen meet your state's residency requirements you can be homeless and still meet these requirements. are 18 years old on or before election day in some states  you can register to vote before you turn 18 if you will be 18 by election day. are registered to vote by your state's voter registration deadline. north dakota does not require voter registration. who can't vote? non-citizens  including permanent legal residents some people with felony convictions. rules vary by state. check with your state elections office about the laws in your state. some people who are mentally incapacitated. rules vary by state. who may have problems voting due to state or local requirements? people who don't present the types of voter id required in their state people who have changed their name or permanent address and have not updated their voter registration people whose name or address on their id doesnt match the name or address on their voter registration people who go to vote on election day at a polling place that is not their assigned polling location who may have problems voting due to logistics? voters with disabilities are guaranteed assistance at the polls by law. learn more about your right to an accessible polling place and assistance in voting. voters with language barriers can get help understanding the ballot. learn more about voting guides and absentee ballots in languages other than english. voters who live overseas  have a disability or injury limiting their mobility  are traveling for business  or attend college out of state can still vote through absentee ballots and early voting in many states. military members and military family members who are stationed away from their polling place can vote through absentee ballot. back to top check or update your voter registration how  when  why every state runs federal and state elections in their own way  as set out in article i and article ii of the constitution  including who can and cannot vote. your state and local election offices will have the exact rules for voting in your state. to vote in every state (except north dakota) you must be registered. register to vote now. if you've recently registered to vote or changed your registration if you've recently turned in a voter registration application or changed your voter registration  it may take a few weeks for your new voter registration card to arrive in the mail. you do not need your physical voter registration card to vote  but you may need other identification. use this interactive map to learn more about id requirements in your state. your state's election office will notify you if there's a problem with your registration. if you don't receive any response  check with your state or local election office. how to check or update your registration information you can check and may be able to change your registration information  including your name  address  and political party online through can i vote. if you need more help  contact your state or local election office to change your name  address  or political party on your voter registration. depending on your state's rules you may be able to make changes to your registration over the phone  online  or by mail. your state may require you to register to vote again to change your information. why you should check your registration information each state has different ways to keep voter registration lists up-to-date  including purging the names of inactive voters. if your election office removes your registration in error and you don't discover this before you go to vote  you may have to cast a provisional ballot. checking ahead of time to be sure you are still registered to vote ensures your name  address  and party affiliation information are up-to-date your registration wasn't mistakenly purged by your state from the list of eligible voters you are able to vote you're voting at the correct polling place what to know about checking and updating your political party affiliation your political party affiliation is the political party that you have chosen to be associated with. your party affiliation may be listed on your voter registration. you are not required to join a political party or reveal your party preference when you register to vote. not every state accepts or lists a party affiliation on a voter registration card. you are not required to vote for any candidate based on the party affiliation that you choose. your party affiliation is generally only important in primary elections. many states have ""closed"" primary elections. this means that you can only choose to vote from among your party's candidates during the primary election. learn more about the different types of primary elections. you can always choose to vote for any candidate regardless of your party registration in a general election  like a presidential  congressional  or mayoral election. when you should re-register or update your registration information anytime you've changed your name anytime you've moved permanently you're not permitted to vote in more than one place. when you register to vote in a new location  you'll be asked for your previous address. your new election office will send a cancellation form to your previous election office. vote in your new location after you've changed your registration address. when you do not have to re-register to vote or update your registration information if your name and address have not changed  you should not have to re-register to vote or update your voter registration. once you are registered  you are eligible to vote in all elections in your area including federal  state  and local elections primary  general  and special elections ballot initiatives  referendums  bond issues  and other legislation that appears on the ballot share this page back to top do you need help? ask us any question about the u. s. government for free. well get you the answer or tell you where to find it. call usa.gov chat with usa.gov email usa.gov what you think matters!was this page helpful? yes no next form approved omb#3090-0297 exp. date 07/31/2019last updated march 01  2018"	how to check if i'm registered to vote
Instrumental: https//www.tutorialspoint.com/cplusplus/cpp_casting_operators.htm c++ casting operators c++ casting operators advertisements previous page next page a cast is a special operator that forces one data type to be converted into another. as an operator  a cast is unary and has the same precedence as any other unary operator. the most general cast supported by most of the c++ compilers is as follows − (type) expression where type is the desired data type. there are other casting operators supported by c++  they are listed below −const_cast<type> (expr) − the const_cast operator is used to explicitly override const and/or volatile in a cast. the target type must be the same as the source type except for the alteration of its const or volatile attributes. this type of casting manipulates the const attribute of the passed object  either to be set or removed.dynamic_cast<type> (expr) − the dynamic_cast performs a runtime cast that verifies the validity of the cast. if the cast cannot be made  the cast fails and the expression evaluates to null. a dynamic_cast performs casts on polymorphic types and can cast a a* pointer into a b* pointer only if the object being pointed to actually is a b object.reinterpret_cast<type> (expr) − the reinterpret_cast operator changes a pointer to any other type of pointer. it also allows casting from pointer to an integer type and vice versa.static_cast<type> (expr) − the static_cast operator performs a nonpolymorphic cast. for example  it can be used to cast a base class pointer into a derived class pointer. all of the above-mentioned casting operators will be used while working with classes and objects. for now  try the following example to understand a simple cast operators available in c++. copy and paste the following c++ program in test.cpp file and compile and run this program. live demo#include <iostream>using namespace std;main () {double a = 21.09399;float b = 10.20;int c;c= ( int) a;cout << line 1 - value of (int)a is  << c << endl;c= ( int) b;cout << line 2 - value of (int)b is  << c << endl;return 0;}when the above code is compiled and executed  it produces the following result −line 1 - value of (int)a is 21 line 2 - value of (int)b is 10previous page print next page advertisements  http//www.cplusplus.com/doc/tutorial/typecasting/ type conversions type conversions implicit conversion implicit conversions are automatically performed when a value is copied to a compatible type. for example1 2 3short a=2000; int b; b=a;here  the value of a is promoted from short to int without the need of any explicit operator. this is known as a standard conversion. standard conversions affect fundamental data types  and allow the conversions between numerical types ( short to int  int to float  double to int ...)  to or from bool  and some pointer conversions. converting to int from some smaller integer type  or to double from float is known as promotion  and is guaranteed to produce the exact same value in the destination type. other conversions between arithmetic types may not always be able to represent the same value exactly if a negative integer value is converted to an unsigned type  the resulting value corresponds to its 2s complement bitwise representation (i.e.  -1 becomes the largest value representable by the type  -2 the second largest  ...). the conversions from/to bool consider false equivalent to zero (for numeric types) and to null pointer (for pointer types); true is equivalent to all other values and is converted to the equivalent of 1. if the conversion is from a floating-point type to an integer type  the value is truncated (the decimal part is removed). if the result lies outside the range of representable values by the type  the conversion causes undefined behavior. otherwise  if the conversion is between numeric types of the same kind (integer-to-integer or floating-to-floating)  the conversion is valid  but the value is implementation-specific (and may not be portable). some of these conversions may imply a loss of precision  which the compiler can signal with a warning. this warning can be avoided with an explicit conversion. for non-fundamental types  arrays and functions implicitly convert to pointers  and pointers in general allow the following conversions null pointers can be converted to pointers of any type pointers to any type can be converted to void pointers. pointer upcast pointers to a derived class can be converted to a pointer of an accessible and unambiguous base class  without modifying its const or volatile qualification. implicit conversions with classes in the world of classes  implicit conversions can be controlled by means of three member functions single-argument constructors allow implicit conversion from a particular type to initialize an object. assignment operator allow implicit conversion from a particular type on assignments. type-cast operator allow implicit conversion to a particular type. for example1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24// implicit conversion of classes#include <iostream>using namespace std; class a {}; class b { public  // conversion from a (constructor) b ( const a& x) {} // conversion from a (assignment) b& operator = ( const a& x) { return * this ;} // conversion to a (type-cast operator)operator a () { return a ();} }; int main () { a foo; b bar = foo; // calls constructor bar = foo; // calls assignment foo = bar; // calls type-cast operatorreturn 0; }edit & run the type-cast operator uses a particular syntax it uses the operator keyword followed by the destination type and an empty set of parentheses. notice that the return type is the destination type and thus is not specified before the operator keyword. keyword explicit on a function call  c++ allows one implicit conversion to happen for each argument. this may be somewhat problematic for classes  because it is not always what is intended. for example  if we add the following function to the last examplevoid fn (b arg) {}this function takes an argument of type b  but it could as well be called with an object of type a as argumentfn (foo);this may or may not be what was intended. but  in any case  it can be prevented by marking the affected constructor with the explicit keyword1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27// explicit#include <iostream>using namespace std; class a {}; class b { public  explicit b ( const a& x) {} b& operator = ( const a& x) { return * this ;} operator a () { return a ();} }; void fn (b x) {} int main () { a foo; b bar (foo); bar = foo; foo = bar; // fn (foo); // not allowed for explicit ctor. fn (bar); return 0; }edit & run additionally  constructors marked with explicit cannot be called with the assignment-like syntax; in the above example  bar could not have been constructed with b bar = foo;type-cast member functions (those described in the previous section) can also be specified as explicit. this prevents implicit conversions in the same way as explicit -specified constructors do for the destination type. type casting c++ is a strong-typed language. many conversions  specially those that imply a different interpretation of the value  require an explicit conversion  known in c++ as type-casting. there exist two main syntaxes for generic type-casting functional and c-like1 2 3 4double x = 10.3; int y; y = int (x); // functional notation y = ( int) x; // c-like cast notation the functionality of these generic forms of type-casting is enough for most needs with fundamental data types. however  these operators can be applied indiscriminately on classes and pointers to classes  which can lead to code that -while being syntactically correct- can cause runtime errors. for example  the following code compiles without errors1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22// class type-casting#include <iostream>using namespace std; class dummy { double i j; }; class addition { int x y; public  addition ( int a  int b) { x=a; y=b; } int result () { return x+y;} }; int main () { dummy d; addition * padd; padd = (addition*) &d; cout << padd->result (); return 0; }edit & run the program declares a pointer to addition  but then it assigns to it a reference to an object of another unrelated type using explicit type-castingpadd = (addition*) &d;unrestricted explicit type-casting allows to convert any pointer into any other pointer type  independently of the types they point to. the subsequent call to member result will produce either a run-time error or some other unexpected results. in order to control these types of conversions between classes  we have four specific casting operators dynamic_cast  reinterpret_cast  static_cast and const_cast. their format is to follow the new type enclosed between angle-brackets ( <>) and immediately after  the expression to be converted between parentheses. dynamic_cast <new_type> (expression) reinterpret_cast <new_type> (expression) static_cast <new_type> (expression) const_cast <new_type> (expression) the traditional type-casting equivalents to these expressions would be (new_type) expression new_type (expression) but each one with its own special characteristicsdynamic_castdynamic_cast can only be used with pointers and references to classes (or with void* ). its purpose is to ensure that the result of the type conversion points to a valid complete object of the destination pointer type. this naturally includes pointer upcast (converting from pointer-to-derived to pointer-to-base)  in the same way as allowed as an implicit conversion. but dynamic_cast can also downcast (convert from pointer-to-base to pointer-to-derived) polymorphic classes (those with virtual members) if -and only if- the pointed object is a valid complete object of the target type. for example1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23// dynamic_cast#include <iostream>#include <exception>using namespace std; class base { virtual void dummy () {} }; class derived public base { int a; }; int main () { try { base * pba = new derived; base * pbb = new base; derived * pd; pd = dynamic_cast <derived*> (pba); if (pd==0) cout << null pointer on first type-cast.\n ; pd = dynamic_cast <derived*> (pbb); if (pd==0) cout << null pointer on second type-cast.\n ; } catch (exception& e) {cout << exception  << e.what ();} return 0; }null pointer on second type-cast. edit & run compatibility note this type of dynamic_cast requires run-time type information (rtti) to keep track of dynamic types. some compilers support this feature as an option which is disabled by default. this needs to be enabled for runtime type checking using dynamic_cast to work properly with these types. the code above tries to perform two dynamic casts from pointer objects of type base* ( pba and pbb) to a pointer object of type derived*  but only the first one is successful. notice their respective initializations1 2base * pba = new derived; base * pbb = new base;even though both are pointers of type base*  pba actually points to an object of type derived  while pbb points to an object of type base. therefore  when their respective type-casts are performed using dynamic_cast  pba is pointing to a full object of class derived  whereas pbb is pointing to an object of class base  which is an incomplete object of class derived. when dynamic_cast cannot cast a pointer because it is not a complete object of the required class -as in the second conversion in the previous example- it returns a null pointer to indicate the failure. if dynamic_cast is used to convert to a reference type and the conversion is not possible  an exception of type bad_cast is thrown instead. dynamic_cast can also perform the other implicit casts allowed on pointers casting null pointers between pointers types (even between unrelated classes)  and casting any pointer of any type to a void* pointer.static_caststatic_cast can perform conversions between pointers to related classes  not only upcasts (from pointer-to-derived to pointer-to-base)  but also downcasts (from pointer-to-base to pointer-to-derived). no checks are performed during runtime to guarantee that the object being converted is in fact a full object of the destination type. therefore  it is up to the programmer to ensure that the conversion is safe. on the other side  it does not incur the overhead of the type-safety checks of dynamic_cast.1 2 3 4class base {}; class derived public base {}; base * a = new base; derived * b = static_cast <derived*> (a);this would be valid code  although b would point to an incomplete object of the class and could lead to runtime errors if dereferenced. therefore  static_cast is able to perform with pointers to classes not only the conversions allowed implicitly  but also their opposite conversions. static_cast is also able to perform all conversions allowed implicitly (not only those with pointers to classes)  and is also able to perform the opposite of these. it can convert from void* to any pointer type. in this case  it guarantees that if the void* value was obtained by converting from that same pointer type  the resulting pointer value is the same. convert integers  floating-point values and enum types to enum types. additionally  static_cast can also perform the following explicitly call a single-argument constructor or a conversion operator. convert to rvalue references. convert enum class values into integers or floating-point values. convert any type to void  evaluating and discarding the value.reinterpret_castreinterpret_cast converts any pointer type to any other pointer type  even of unrelated classes. the operation result is a simple binary copy of the value from one pointer to the other. all pointer conversions are allowed neither the content pointed nor the pointer type itself is checked. it can also cast pointers to or from integer types. the format in which this integer value represents a pointer is platform-specific. the only guarantee is that a pointer cast to an integer type large enough to fully contain it (such as intptr_t )  is guaranteed to be able to be cast back to a valid pointer. the conversions that can be performed by reinterpret_cast but not by static_cast are low-level operations based on reinterpreting the binary representations of the types  which on most cases results in code which is system-specific  and thus non-portable. for example1 2 3 4class a { /* ... */ }; class b { /* ... */ }; a * a = new a; b * b = reinterpret_cast <b*> (a);this code compiles  although it does not make much sense  since now b points to an object of a totally unrelated and likely incompatible class. dereferencing b is unsafe.const_cast this type of casting manipulates the constness of the object pointed by a pointer  either to be set or to be removed. for example  in order to pass a const pointer to a function that expects a non-const argument1 2 3 4 5 6 7 8 9 10 11 12 13 14// const_cast#include <iostream>using namespace std; void print ( char * str) { cout << str << \n ; } int main () { const char * c = sample text ; print ( const_cast < char *> (c) ); return 0; }sample text edit & run the example above is guaranteed to work because function print does not write to the pointed object. note though  that removing the constness of a pointed object to actually write to it causes undefined behavior.typeidtypeid allows to check the type of an expression typeid (expression) this operator returns a reference to a constant object of type type_info that is defined in the standard header <typeinfo>. a value returned by typeid can be compared with another value returned by typeid using operators == and != or can serve to obtain a null-terminated character sequence representing the data type or class name by using its name () member.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16// typeid#include <iostream>#include <typeinfo>using namespace std; int main () { int * a b; a=0; b=0; if ( typeid (a) != typeid (b)) { cout << a and b are of different types\n ; cout << a is  << typeid (a).name () << \n ; cout << b is  << typeid (b).name () << \n ; } return 0; }a and b are of different types a is int * b is int edit & run when typeid is applied to classes  typeid uses the rtti to keep track of the type of dynamic objects. when typeid is applied to an expression whose type is a polymorphic class  the result is the type of the most derived complete object1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20// typeid  polymorphic class#include <iostream>#include <typeinfo>#include <exception>using namespace std; class base { virtual void f () {} }; class derived  public base {}; int main () { try { base* a = new base; base* b = new derived; cout << a is  << typeid (a).name () << \n ; cout << b is  << typeid (b).name () << \n ; cout << *a is  << typeid (*a).name () << \n ; cout << *b is  << typeid (*b).name () << \n ; } catch (exception& e) { cout << exception  << e.what () << \n; } return 0; }a is class base * b is class base * *a is class base *b is class derived edit & run note the string returned by member name of type_info depends on the specific implementation of your compiler and library. it is not necessarily a simple string with its typical type name  like in the compiler used to produce this output. notice how the type that typeid considers for pointers is the pointer type itself (both a and b are of type class base * ). however  when typeid is applied to objects (like *a and *b) typeid yields their dynamic type (i.e. the type of their most derived complete object). if the type typeid evaluates is a pointer preceded by the dereference operator ( * )  and this pointer has a null value  typeid throws a bad_typeid exception. previous polymorphism index next exceptions  http//www.bogotobogo.com/cplusplus/upcasting_downcasting.php upcasting and downcasting - 2018 upcasting and downcasting - 2018bogotobogo.com site search upcasting and downcasting upcasting upcasting is converting a derived-class reference or pointer to a base-class. in other words  upcasting allows us to treat a derived type as though it were its base type. it is always allowed for public inheritance  without an explicit type cast. this is a result of the is-a relationship between the base and derived classes. here is the code dealing with shapes. we created shape class  and derived circle  square  and triangle classes from the shape class. then  we made a member function that talks to the base classvoid play (shape& s) { s.draw (); s.move (); s.shrink (); .... }the function speaks to any shape  so it is independent of the specific type of object that its drawing  moving  and shrinking. if in some other part of the program we use the play ( ) function like below circle c; triangle t; square sq; play (c); play (t); play (sq);lets check whats happening here. a triangle is being passed into a function that is expecting a shape. since a triangle is a shape  it can be treated as one by play (). that is  any message that play () can send to a shape a triangle can accept. upcasting allows us to treat a derived type as though it were its base type. thats how we decouple ourselves from knowing about the exact type we are dealing with. note that it doesnt say if youre a triangle  do this  if youre a circle  do that  and so on. if we write that kind of code  which checks for all the possible types of a shape  it will soon become a messy code  and we need to change it every time we add a new kind of shape . here  however  we just say youre a shape  i know you can move ()  draw ()  and shrink ( ) yourself  do it  and take care of the details correctly. the compiler and runtime linker handle the details. if a member function is virtual  then when we send a message to an object  the object will do the right thing  even when upcasting is involved. note that the most important aspect of inheritance is not that it provides member functions for the new class  however. its the relationship expressed between the new class and the base class. this relationship can be summarized by saying  the new class is a type of the existing class. class parent { public void sleep () {} }; class child public parent { public void goto school () {} }; int main ( ) { parent parent; child child; // upcast - implicit type cast allowed parent *p parent = &child; // downcast - explicit type case required child *p child = (child *) &parent; p parent -> sleep (); p child -> goto school (); return 0; }a child object is a parent object in that it inherits all the data members and member functions of a parent object. so  anything that we can do to a parent object  we can do to a child object. therefore  a function designed to handle a parent pointer (reference) can perform the same acts on a child object without any problems. the same idea applies if we pass a pointer to an object as a function argument. upcasting is transitive if we derive a child class from parent  then parent pointer (reference) can refer to a parent or a child object. upcasting can cause object slicing when a derived class object is passed by value as a base class object  as in foo (base derived_obj). downcasting the opposite process  converting a base-class pointer (reference) to a derived-class pointer (reference) is called downcasting. downcasting is not allowed without an explicit type cast. the reason for this restriction is that the is-a relationship is not  in most of the cases  symmetric. a derived class could add new data members  and the class member functions that used these data members wouldnt apply to the base class. as in the example  we derived child class from a parent class  adding a member function  goto school (). it wouldnt make sense to apply the goto school () method to a parent object. however  if implicit downcasting were allowed  we could accidentally assign the address of a parent object to a pointer-to- child child *p child = &parent; // actually this wont compile // error cannot convert from parent * to child *and use the pointer to invoke the goto school () method as in the following line.p child -> goto school ();because a parent isnt a child (a parent need not have a goto school () method)  the downcasting in the above line can lead to an unsafe operation. c++ provides a special explicit cast called dynamic_cast that performs this conversion. downcasting is the opposite of the basic object-oriented rule  which states objects of a derived class  can always be assigned to variables of a base class. one more thing about the upcasting because implicit upcasting makes it possible for a base-class pointer (reference) to refer to a base-class object or a derived-class object  there is the need for dynamic binding. thats why we have virtual member functions. pointer (reference) type known at compile time. object type not known until run time. dynamic casting the dynamic_cast operator answers the question of whether we can safely assign the address of an object to a pointer of a particular type. here is a similar example to the previous one.#include <string> class parent { public void sleep () { } }; class child public parent { private stdstring classes [10]; public void goto school () {} }; int main ( ) { parent *p parent = new parent; parent *p child = new child; child *p1 = (child *) p parent; // #1 parent *p2 = (child *) p child; // #2 return 0; }let look at the lines where we do type cast. child *p1 = (child *) p parent; // #1 parent *p2 = (child *) p child; // #2which of the type cast is safe? the only one guaranteed to be safe is the ones in which the pointer is the same type as the object or else a base type for the object. type cast #1 is not safe because it assigns the address of a base-class object ( parent) to a derived class ( child) pointer. so  the code would expect the base-class object to have derived class properties such as goto school () method  and that is false. also  child object  for example  has a member classes that a parent object is lacking. type case #2  however  is safe because it assigns the address of a derived-class object to a base-class pointer. in other words  public derivation promises that a child object is also a parent object. the question of whether a type conversion is safe is more useful than the question of what kind of object is pointed to. the usual reason for wanting to know the type is so that we can know if its safe to invoke a particular method. here is the syntax of dynamic_cast. child *p = dynamic_cast <child *> (p parent)this code is asking whether the pointer p parent can be type cast safely to the type child *. it returns the address of the object  if it can. it returns 0  otherwise. how do we use the dynamic_cast?void f ( parent * p) { child *ptr = dynamic_cast <child*> (p); if (ptr) { // we can safely use ptr } }in the code  if (ptr) is of the type child or else derived directly or indirectly from the type child  the dynamic_cast converts the pointer p to a pointer of type child. otherwise  the expression evaluates to 0  the null pointer. in other words  we want to check if we can use the passed in pointer p before we do some operation on a child class object even though its a pointer to base class. the need for dynamic_cast generally arises because we want perform derived class operation on a derived class object  but we have only a pointer-or reference-to- base . -scott meyers 	casting in c++
